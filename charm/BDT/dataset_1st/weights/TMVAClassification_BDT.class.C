// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.18/04       [397828]
Creator        : vale
Date           : Thu Feb 13 12:53:24 2020
Host           : Linux vale-ESPRIMO-P556-2 4.15.0-64-generic #73-Ubuntu SMP Thu Sep 12 13:16:13 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/vale/Desktop/DecaySearch/CH1_MC_CHARM_CASCADE/MC_charm/TMVA
Training events: 16472
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "75" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 3
probability                   probability                   probability                   probability                                                     'F'    [0.0100067192689,1]
maxaperture                   maxaperture                   maxaperture                   maxaperture                                                     'F'    [0.000866754504386,1.53956854343]
meanIP/maxIP                  IP_var                        IP_var                        IP_var                                                          'F'    [0.0714154541492,0.999994814396]
NSpec 3
vID                           vID                           vID                           Index of the vertex           units                             'F'    [1,50931]
meanTX                        meanTX                        meanTX                        meanTX                        units                             'F'    [-0.707458376884,0.612873077393]
meanTY                        meanTY                        meanTY                        meanTY                        units                             'F'    [-0.574897229671,0.543409943581]


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTNode

#ifndef BDTNode__def
#define BDTNode__def

class BDTNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 3 )
   {
      // the training input variables
      const char* inputVars[] = { "probability", "maxaperture", "meanIP/maxIP" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[3];
   double fVmax[3];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[3];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDT::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(1.54728913203969);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.305321, 1, 1, 0.97499,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.785629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.144095,-99) , 
1, 0.344118, 0, 0, 0.573029,-99) , 
0, 0.952894, 0, 0, 0.907396,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.98878, 0, 0, 0.274731,-99) , 
NN(
0, 
0, 
-1, 0.585697, 1, -1, 0.00496119,-99) , 
0, 0.952857, 0, 0, 0.042676,-99) , 
2, 0.51654, 1, 0, 0.48822,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.995243);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.329034, 1, 1, 0.860454,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529149,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.168424,-99) , 
0, 0.811603, 0, 0, 0.346289,-99) , 
NN(
0, 
0, 
-1, 0.656058, 1, -1, 0.0164429,-99) , 
2, 0.619717, 1, 0, 0.110854,-99) , 
2, 0.429473, 1, 0, 0.46777,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.91138);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.219356, 1, 1, 0.887602,-99) , 
NN(
0, 
0, 
-1, 0.575943, 0, -1, 0.395005,-99) , 
2, 0.323804, 1, 0, 0.704725,-99) , 
NN(
0, 
0, 
-1, 0.952857, 0, -1, 0.0509326,-99) , 
2, 0.474443, 1, 0, 0.397391,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.726688);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.228852, 1, 1, 0.816403,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.680926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4809,-99) , 
1, 0.377316, 0, 0, 0.568257,-99) , 
2, 0.326176, 1, 0, 0.707016,-99) , 
NN(
0, 
0, 
-1, 0.952862, 0, -1, 0.0317987,-99) , 
2, 0.55781, 1, 0, 0.454804,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.894538);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.301405, 1, 1, 0.875278,-99) , 
NN(
0, 
0, 
-1, 0.652447, 1, -1, 0.187471,-99) , 
0, 0.995511, 0, 0, 0.754523,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.179812,-99) , 
0, 0.36919, 0, 0, 0.440638,-99) , 
NN(
0, 
0, 
-1, 0.099791, 1, -1, 0.0562017,-99) , 
2, 0.477279, 1, 0, 0.167147,-99) , 
0, 0.952857, 0, 0, 0.475067,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.678046);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.269701, 1, 1, 0.751558,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.694879,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.307481,-99) , 
2, 0.488312, 0, 0, 0.424297,-99) , 
0, 0.95286, 0, 0, 0.626081,-99) , 
NN(
0, 
0, 
-1, 0.952873, 0, -1, 0.0830344,-99) , 
2, 0.557814, 1, 0, 0.435409,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.64525);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.806626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366439,-99) , 
0, 0.995512, 0, 0, 0.739518,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.263908,-99) , 
0, 0.369282, 1, 0, 0.403195,-99) , 
0, 0.952869, 0, 0, 0.59907,-99) , 
NN(
0, 
0, 
-1, 0.952872, 0, -1, 0.00947894,-99) , 
2, 0.692341, 1, 0, 0.502349,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.515619);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377197,-99) , 
2, 0.554553, 1, 0, 0.63675,-99) , 
NN(
0, 
0, 
-1, 0.481048, 1, -1, 0.177481,-99) , 
0, 0.340039, 0, 0, 0.583971,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564541,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.129162,-99) , 
1, 0.247576, 0, 0, 0.355473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.952862, 0, 0, 0.0864115,-99) , 
2, 0.605012, 1, 0, 0.464051,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.486508);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685077,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.237159,-99) , 
0, 0.905789, 0, 0, 0.475936,-99) , 
2, 0.279746, 1, 0, 0.588122,-99) , 
NN(
0, 
0, 
-1, 0.90572, 0, -1, 0.158,-99) , 
2, 0.469377, 1, 0, 0.428287,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.377956);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.317644,-99) , 
0, 0.993268, 0, 0, 0.523567,-99) , 
NN(
0, 
0, 
-1, 0.449082, 0, -1, 0.300961,-99) , 
0, 0.952864, 0, 0, 0.448566,-99) , 
NN(
0, 
0, 
-1, 0.337517, 0, -1, 0.0264358,-99) , 
2, 0.690468, 1, 0, 0.385487,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.379523);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.669145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.178763,-99) , 
1, 0.106902, 0, 0, 0.600473,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377243,-99) , 
0, 0.905765, 1, 0, 0.415602,-99) , 
1, 0.433695, 1, 0, 0.481161,-99) , 
NN(
0, 
0, 
-1, 0.680023, 1, -1, 0.0394633,-99) , 
2, 0.64625, 1, 0, 0.408067,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.48542);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441031,-99) , 
1, 0.496739, 0, 0, 0.566211,-99) , 
NN(
0, 
0, 
-1, 0.975881, 0, -1, 0.253052,-99) , 
0, 0.993278, 0, 0, 0.502253,-99) , 
NN(
0, 
0, 
-1, 0.479814, 1, -1, 0.16622,-99) , 
0, 0.952864, 0, 0, 0.365797,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.259176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.859188,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530719,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.382423,-99) , 
0, 0.811464, 0, 0, 0.497365,-99) , 
2, 0.618773, 0, 0, 0.525279,-99) , 
NN(
0, 
0, 
-1, 0.952868, 0, -1, 0.070493,-99) , 
2, 0.64625, 1, 0, 0.457879,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.388824);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.746915,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418635,-99) , 
2, 0.377866, 1, 0, 0.557006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356872,-99) , 
1, 0.649926, 1, 0, 0.485642,-99) , 
NN(
0, 
0, 
-1, 0.778925, 1, -1, 0.0280145,-99) , 
2, 0.690451, 1, 0, 0.433493,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.330457);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.340523, 0, 1, 0.57978,-99) , 
NN(
0, 
0, 
-1, 0.314165, 0, -1, 0.391868,-99) , 
0, 0.995511, 0, 0, 0.539599,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.136854,-99) , 
0, 0.324197, 0, 0, 0.384852,-99) , 
NN(
0, 
0, 
-1, 0.862956, 0, -1, 0.021243,-99) , 
2, 0.562035, 1, 0, 0.26395,-99) , 
0, 0.95286, 0, 0, 0.431506,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.255164);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.211593, 1, 1, 0.562381,-99) , 
NN(
0, 
0, 
-1, 0.340515, 0, -1, 0.382583,-99) , 
2, 0.366196, 1, 0, 0.491286,-99) , 
NN(
0, 
0, 
-1, 0.764195, 1, -1, 0.0403768,-99) , 
2, 0.690468, 1, 0, 0.442362,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.229135);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454432,-99) , 
2, 0.457937, 0, 0, 0.489279,-99) , 
NN(
0, 
0, 
-1, 0.0570378, 0, -1, 0.270795,-99) , 
0, 0.340039, 0, 0, 0.469159,-99) , 
NN(
0, 
0, 
-1, 0.952862, 0, -1, 0.0868789,-99) , 
2, 0.648391, 1, 0, 0.426205,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.374491);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.271535,-99) , 
0, 0.340124, 0, 0, 0.561924,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.207919,-99) , 
2, 0.256692, 1, 0, 0.388416,-99) , 
1, 0.51721, 1, 0, 0.464726,-99) , 
NN(
0, 
0, 
-1, 0.952862, 0, -1, 0.143129,-99) , 
2, 0.557814, 1, 0, 0.405916,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.35176);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.604265,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369588,-99) , 
0, 0.993272, 0, 0, 0.552841,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.264967,-99) , 
0, 0.369128, 1, 0, 0.365314,-99) , 
0, 0.952857, 0, 0, 0.480817,-99) , 
NN(
0, 
0, 
-1, 0.781848, 1, -1, 0.0529261,-99) , 
2, 0.694503, 1, 0, 0.442443,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.185327);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477976,-99) , 
2, 0.223524, 1, 0, 0.51057,-99) , 
NN(
0, 
0, 
-1, 0.0884638, 1, -1, 0.265048,-99) , 
0, 0.340039, 0, 0, 0.490813,-99) , 
NN(
0, 
0, 
-1, 0.780251, 1, -1, 0.069856,-99) , 
2, 0.692341, 1, 0, 0.452962,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.240479);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.841116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440974,-99) , 
0, 0.847357, 1, 0, 0.460646,-99) , 
NN(
0, 
0, 
-1, 0.479376, 1, -1, 0.323367,-99) , 
0, 0.81143, 0, 0, 0.427536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.780242, 1, 0, 0.406207,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.322783);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.804722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.218356,-99) , 
1, 0.224774, 0, 0, 0.680563,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376515,-99) , 
2, 0.28026, 1, 0, 0.456344,-99) , 
2, 0.542762, 0, 0, 0.492905,-99) , 
NN(
0, 
0, 
-1, 0.189845, 0, -1, 0.0451876,-99) , 
2, 0.650847, 1, 0, 0.45044,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.233169);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.618791,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348871,-99) , 
0, 0.71716, 0, 0, 0.581856,-99) , 
NN(
0, 
0, 
-1, 0.71901, 1, -1, 0.432806,-99) , 
1, 0.40414, 1, 0, 0.473933,-99) , 
NN(
0, 
0, 
-1, 0.498877, 1, -1, 0.090205,-99) , 
1, 0.144844, 0, 0, 0.436557,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.179007);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.465965, 1, 1, 0.5558,-99) , 
NN(
0, 
0, 
-1, 0.16711, 0, -1, 0.330647,-99) , 
0, 0.340089, 0, 0, 0.539325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.734685, 1, 0, 0.509073,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.294364);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466502,-99) , 
1, 0.38709, 0, 0, 0.586705,-99) , 
NN(
0, 
0, 
-1, 0.45463, 1, -1, 0.327857,-99) , 
0, 0.71721, 0, 0, 0.53874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.690468, 1, 0, 0.50342,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.266844);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0735419,-99) , 
1, 0.0935964, 0, 0, 0.527185,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.704467,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327214,-99) , 
0, 0.905818, 1, 0, 0.4217,-99) , 
1, 0.646309, 1, 0, 0.489186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.734686, 1, 0, 0.464295,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.286256);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.670204, 1, 1, 0.61501,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.246199,-99) , 
1, 0.190455, 0, 0, 0.439429,-99) , 
NN(
0, 
0, 
-1, 0.315457, 1, -1, 0.0104216,-99) , 
0, 0.811474, 0, 0, 0.351218,-99) , 
1, 0.440996, 0, 0, 0.498624,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.258018);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.741816,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366029,-99) , 
2, 0.19938, 1, 0, 0.397496,-99) , 
2, 0.713675, 0, 0, 0.410808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.780549, 1, 0, 0.395907,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.245463);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419479,-99) , 
2, 0.452843, 1, 0, 0.583193,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393448,-99) , 
0, 0.95286, 1, 0, 0.43319,-99) , 
1, 0.323291, 1, 0, 0.475803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.778903, 1, 0, 0.457132,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.229844);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607231,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435554,-99) , 
1, 0.503033, 0, 0, 0.509622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366434,-99) , 
2, 0.202604, 0, 0, 0.468162,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.736286, 1, 0, 0.450286,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.157389);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710041,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495078,-99) , 
2, 0.542042, 0, 0, 0.52274,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.279446,-99) , 
1, 0.330458, 1, 0, 0.414131,-99) , 
1, 0.433807, 0, 0, 0.478831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.778904, 1, 0, 0.463256,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.385778);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.996261, 1, 1, 0.662717,-99) , 
NN(
0, 
0, 
-1, 0.966307, 0, -1, 0.415216,-99) , 
0, 0.984289, 0, 0, 0.6343,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.763091,-99) , 
NN(
0, 
0, 
-1, 0.570456, 1, -1, 0.266194,-99) , 
1, 0.721966, 0, 0, 0.376155,-99) , 
0, 0.952866, 0, 0, 0.544525,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.16801);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588929,-99) , 
NN(
0, 
0, 
-1, 0.717145, 0, -1, 0.44854,-99) , 
2, 0.260732, 1, 0, 0.50244,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.734686, 1, 0, 0.482329,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.248073);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.38913,-99) , 
1, 0.641208, 1, 0, 0.513295,-99) , 
NN(
0, 
0, 
-1, 0.443284, 0, -1, 0.23046,-99) , 
0, 0.622955, 0, 0, 0.483456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.736292, 1, 0, 0.463491,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.30147);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.450101, 0, 1, 0.746636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395858,-99) , 
0, 0.952864, 1, 0, 0.43754,-99) , 
1, 0.310557, 1, 0, 0.492901,-99) , 
NN(
0, 
0, 
-1, 0.90572, 0, -1, 0.212497,-99) , 
2, 0.519936, 1, 0, 0.447674,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.157933);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478152,-99) , 
1, 0.504189, 0, 0, 0.52792,-99) , 
NN(
0, 
0, 
-1, 0.387168, 1, -1, 0.345882,-99) , 
0, 0.575771, 0, 0, 0.507576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.734686, 1, 0, 0.488682,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.244184);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430985,-99) , 
2, 0.342729, 0, 0, 0.516341,-99) , 
NN(
0, 
0, 
-1, 0.458713, 1, -1, 0.339452,-99) , 
0, 0.717145, 0, 0, 0.49243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.692784, 1, 0, 0.472761,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.288405);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.252454, 0, 1, 0.594906,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613698,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.285093,-99) , 
1, 0.270487, 0, 0, 0.517943,-99) , 
NN(
0, 
0, 
-1, 0.189575, 1, -1, 0.154175,-99) , 
0, 0.952857, 0, 0, 0.381786,-99) , 
2, 0.384689, 1, 0, 0.516911,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.212669);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.66382,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49582,-99) , 
1, 0.610635, 0, 0, 0.574399,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.618729,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409637,-99) , 
2, 0.584117, 0, 0, 0.459209,-99) , 
2, 0.312396, 1, 0, 0.515287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.69279, 1, 0, 0.494576,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.335963);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.653999,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401254,-99) , 
0, 0.717145, 0, 0, 0.61685,-99) , 
NN(
0, 
0, 
-1, 0.952868, 0, -1, 0.236791,-99) , 
2, 0.611795, 1, 0, 0.566961,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568717,-99) , 
NN(
0, 
0, 
-1, 0.955227, 0, -1, 0.314266,-99) , 
0, 0.764452, 1, 0, 0.364308,-99) , 
1, 0.577453, 1, 0, 0.474889,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.214669);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457355,-99) , 
2, 0.294635, 0, 0, 0.516206,-99) , 
NN(
0, 
0, 
-1, 0.147952, 1, -1, 0.301781,-99) , 
1, 0.219555, 0, 0, 0.484688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0114529,-99) , 
2, 0.648391, 1, 0, 0.45903,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.251169);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.658651,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493713,-99) , 
2, 0.210345, 0, 0, 0.57358,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.848737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443561,-99) , 
2, 0.65283, 0, 0, 0.513621,-99) , 
NN(
0, 
0, 
-1, 0.561933, 1, -1, 0.162769,-99) , 
0, 0.952857, 0, 0, 0.418552,-99) , 
2, 0.336716, 1, 0, 0.499033,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.362721);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.773178,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.650394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491099,-99) , 
0, 0.997756, 0, 0, 0.611118,-99) , 
1, 0.64783, 0, 0, 0.656144,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.729331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401516,-99) , 
0, 0.458918, 1, 0, 0.538894,-99) , 
NN(
0, 
0, 
-1, 0.817755, 0, -1, 0.133555,-99) , 
2, 0.517245, 1, 0, 0.442138,-99) , 
0, 0.952857, 0, 0, 0.587044,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.230281);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.222969, 1, 1, 0.608386,-99) , 
NN(
0, 
0, 
-1, 0.81145, 0, -1, 0.380412,-99) , 
2, 0.336724, 1, 0, 0.511476,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.216777);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444522,-99) , 
1, 0.175077, 0, 0, 0.578693,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416535,-99) , 
2, 0.298819, 0, 0, 0.503358,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554298,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.952862, 0, 0, 0.289599,-99) , 
2, 0.602031, 1, 0, 0.485178,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.245889);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702948,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.64292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43456,-99) , 
2, 0.565569, 0, 0, 0.457135,-99) , 
NN(
0, 
0, 
-1, 0.858605, 0, -1, 0.0573332,-99) , 
2, 0.624656, 1, 0, 0.43012,-99) , 
2, 0.211668, 1, 0, 0.487121,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.159421);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.746854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451075,-99) , 
0, 0.952871, 0, 0, 0.635692,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.690799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460942,-99) , 
2, 0.633628, 0, 0, 0.47065,-99) , 
1, 0.290735, 1, 0, 0.498724,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.113231,-99) , 
2, 0.692341, 1, 0, 0.484288,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.22761);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707297,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277997,-99) , 
0, 0.340171, 0, 0, 0.672377,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.215211,-99) , 
1, 0.221658, 0, 0, 0.472469,-99) , 
2, 0.497788, 1, 0, 0.603922,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477961,-99) , 
2, 0.296788, 0, 0, 0.550014,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.339378);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.65343,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.129603,-99) , 
1, 0.702893, 1, 0, 0.480858,-99) , 
2, 0.336561, 1, 0, 0.595399,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.730312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374608,-99) , 
1, 0.285635, 1, 0, 0.492146,-99) , 
NN(
0, 
0, 
-1, 0.514022, 1, -1, 0.154147,-99) , 
1, 0.16907, 0, 0, 0.419824,-99) , 
1, 0.441093, 0, 0, 0.526092,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.205997);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460231,-99) , 
1, 0.42223, 1, 0, 0.521264,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.142717,-99) , 
2, 0.692341, 1, 0, 0.508572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.263317,-99) , 
1, 0.806853, 1, 0, 0.472364,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.257242);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.686882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.350076,-99) , 
1, 0.191703, 0, 0, 0.60986,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.370296,-99) , 
1, 0.600174, 0, 0, 0.493776,-99) , 
1, 0.442631, 1, 0, 0.539537,-99) , 
NN(
0, 
0, 
-1, 0.474444, 1, -1, 0.382774,-99) , 
0, 0.905715, 0, 0, 0.499679,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.250305);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.541594, 0, 1, 0.602104,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.687656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397405,-99) , 
0, 0.811531, 1, 0, 0.418483,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0396809,-99) , 
0, 0.717174, 0, 0, 0.374264,-99) , 
2, 0.346597, 1, 0, 0.504204,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.228436);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.347366, 1, 1, 0.574728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54018,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.359126,-99) , 
2, 0.268819, 0, 0, 0.441472,-99) , 
0, 0.905739, 1, 0, 0.468483,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290996,-99) , 
1, 0.368531, 1, 0, 0.430082,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.905715, 0, 0, 0.294335,-99) , 
2, 0.517245, 1, 0, 0.446457,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.231625);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647532,-99) , 
NN(
0, 
0, 
-1, 0.661201, 1, -1, 0.398084,-99) , 
2, 0.208888, 1, 0, 0.462989,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.215871);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.752174,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413668,-99) , 
1, 0.293953, 0, 0, 0.509877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.146983,-99) , 
0, 0.387211, 0, 0, 0.492918,-99) , 
2, 0.204068, 1, 0, 0.546887,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.244809);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665377,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443924,-99) , 
2, 0.56241, 1, 0, 0.564829,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575666,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389944,-99) , 
2, 0.211456, 1, 0, 0.443463,-99) , 
2, 0.386851, 0, 0, 0.485587,-99) , 
NN(
0, 
0, 
-1, 0.0997595, 1, -1, 0.231776,-99) , 
0, 0.481432, 0, 0, 0.463033,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.293132);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.739342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360229,-99) , 
1, 0.294871, 0, 0, 0.641351,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575984,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362362,-99) , 
2, 0.258138, 0, 0, 0.49155,-99) , 
0, 0.991024, 1, 0, 0.529484,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.718135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366122,-99) , 
2, 0.454468, 0, 0, 0.433436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 0.517246, 1, 0, 0.365416,-99) , 
0, 0.81143, 0, 0, 0.500349,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.192415);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.230375, 1, 1, 0.562128,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547236,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.272868,-99) , 
1, 0.222868, 0, 0, 0.511877,-99) , 
NN(
0, 
0, 
-1, 0.288119, 1, -1, 0.03619,-99) , 
0, 0.905727, 0, 0, 0.402473,-99) , 
2, 0.390157, 1, 0, 0.508931,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.209002);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.592477,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465215,-99) , 
1, 0.535083, 0, 0, 0.523524,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651281,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356094,-99) , 
0, 0.387147, 1, 0, 0.399458,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.256586,-99) , 
2, 0.473752, 0, 0, 0.344607,-99) , 
2, 0.385583, 1, 0, 0.462019,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.244143);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634297,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.69889,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457797,-99) , 
2, 0.596103, 0, 0, 0.50601,-99) , 
NN(
0, 
0, 
-1, 0.461637, 1, -1, 0.23706,-99) , 
0, 0.90572, 0, 0, 0.454069,-99) , 
2, 0.292506, 1, 0, 0.525523,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.242608);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.149158, 1, 1, 0.780867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.231244,-99) , 
1, 0.114859, 0, 0, 0.668988,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479646,-99) , 
2, 0.248219, 1, 0, 0.517927,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.117898,-99) , 
1, 0.305759, 1, 0, 0.228749,-99) , 
1, 0.341359, 0, 0, 0.462527,-99) , 
1, 0.217803, 1, 0, 0.49123,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.167263);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.306052, 1, 1, 0.560097,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566089,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339977,-99) , 
1, 0.428364, 1, 0, 0.442497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 0.90572, 0, 0, 0.358876,-99) , 
2, 0.513595, 1, 0, 0.524764,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.214392);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.675094,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630061,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.206066,-99) , 
1, 0.0976331, 0, 0, 0.577353,-99) , 
NN(
0, 
0, 
-1, 0.473667, 1, -1, 0.439808,-99) , 
1, 0.289836, 1, 0, 0.479044,-99) , 
2, 0.210042, 1, 0, 0.522249,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.198857);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56788,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490775,-99) , 
1, 0.723852, 1, 0, 0.549488,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.252922,-99) , 
0, 0.404724, 1, 0, 0.400377,-99) , 
0, 0.764312, 0, 0, 0.51972,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665045,-99) , 
NN(
0, 
0, 
-1, 0.966362, 0, -1, 0.253816,-99) , 
0, 0.76447, 1, 0, 0.359547,-99) , 
1, 0.221827, 0, 0, 0.494572,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.248248);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.645543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468404,-99) , 
0, 0.952857, 0, 0, 0.606862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.136457,-99) , 
2, 0.644806, 1, 0, 0.578433,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401484,-99) , 
2, 0.253928, 0, 0, 0.512583,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.231102);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438677,-99) , 
1, 0.703244, 1, 0, 0.554067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.714929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366255,-99) , 
1, 0.124411, 1, 0, 0.432445,-99) , 
1, 0.368531, 0, 0, 0.513991,-99) , 
NN(
0, 
0, 
-1, 0.429459, 1, -1, 0.356867,-99) , 
0, 0.81144, 0, 0, 0.48958,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.19008);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.387474, 1, 1, 0.721588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.284483,-99) , 
2, 0.533551, 1, 0, 0.612585,-99) , 
NN(
NN(
0, 
0, 
-1, 0.413445, 1, 1, 0.75032,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578297,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457499,-99) , 
0, 0.85859, 1, 0, 0.481071,-99) , 
2, 0.604235, 0, 0, 0.505063,-99) , 
1, 0.29452, 1, 0, 0.523745,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.222183);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.95289, 0, 1, 0.629392,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461455,-99) , 
2, 0.21632, 0, 0, 0.559484,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559264,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.170094,-99) , 
2, 0.672192, 1, 0, 0.48395,-99) , 
NN(
0, 
0, 
-1, 0.274845, 1, -1, 0.277084,-99) , 
2, 0.540913, 0, 0, 0.398299,-99) , 
2, 0.43265, 1, 0, 0.516289,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.422693);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.7286,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655291,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0893088,-99) , 
0, 0.991024, 0, 0, 0.580565,-99) , 
NN(
0, 
0, 
-1, 0.57251, 1, -1, 0.333536,-99) , 
0, 0.952864, 0, 0, 0.502232,-99) , 
2, 0.248288, 1, 0, 0.588138,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.180295);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.786597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.165094,-99) , 
1, 0.105424, 0, 0, 0.659916,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371666,-99) , 
2, 0.472534, 1, 0, 0.496797,-99) , 
1, 0.220681, 1, 0, 0.519824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.23856,-99) , 
0, 0.151434, 0, 0, 0.508391,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.225891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.38745, 1, 1, 0.626877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32994,-99) , 
1, 0.104278, 0, 0, 0.594578,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627168,-99) , 
NN(
0, 
0, 
-1, 0.479502, 1, -1, 0.405027,-99) , 
1, 0.742155, 0, 0, 0.465613,-99) , 
1, 0.360087, 1, 0, 0.499496,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.174662);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.450605, 0, 1, 0.779239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430623,-99) , 
1, 0.292744, 0, 0, 0.523498,-99) , 
0, 0.717145, 1, 0, 0.572959,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524269,-99) , 
NN(
0, 
0, 
-1, 0.697807, 0, -1, 0.344899,-99) , 
0, 0.952886, 0, 0, 0.459861,-99) , 
1, 0.55657, 1, 0, 0.528318,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.169648);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.835989,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468393,-99) , 
2, 0.323666, 0, 0, 0.499801,-99) , 
1, 0.147675, 1, 0, 0.518477,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.231624,-99) , 
1, 0.531104, 0, 0, 0.317709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0934851,-99) , 
2, 0.560177, 0, 0, 0.258566,-99) , 
2, 0.513596, 1, 0, 0.482173,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.204023);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58544,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.112079,-99) , 
0, 0.727596, 1, 0, 0.47312,-99) , 
0, 0.952869, 0, 0, 0.554266,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440243,-99) , 
0, 0.946144, 1, 0, 0.470356,-99) , 
NN(
0, 
0, 
-1, 0.391696, 1, -1, 0.302866,-99) , 
0, 0.81145, 0, 0, 0.447499,-99) , 
1, 0.505379, 0, 0, 0.500048,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.225191);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.762393,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.183262,-99) , 
2, 0.555866, 1, 0, 0.507847,-99) , 
1, 0.331518, 0, 0, 0.586713,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514871,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378167,-99) , 
2, 0.623903, 0, 0, 0.399261,-99) , 
2, 0.20999, 1, 0, 0.436133,-99) , 
1, 0.387055, 1, 0, 0.486158,-99)    );
   return;
};

// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
