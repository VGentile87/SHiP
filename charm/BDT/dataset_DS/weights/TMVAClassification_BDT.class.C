// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.18/04       [397828]
Creator        : vale
Date           : Mon Feb 17 12:03:12 2020
Host           : Linux vale-ESPRIMO-P556-2 4.15.0-64-generic #73-Ubuntu SMP Thu Sep 12 13:16:13 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/vale/Desktop/DecaySearch/CH1_R6/CH1_MC_CHARM_CASCADE/MC_charm/TMVA
Training events: 5514
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "75" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 8
tka_rms                       tka_rms                       tka_rms                       tka_rms                                                         'F'    [0.000848022056744,0.0563478060067]
kink                          kink                          kink                          kink                                                            'F'    [0.00248789554462,4.03539657593]
impact                        impact                        impact                        impact                                                          'F'    [1.5966783762,5705.65722656]
decaylength                   decaylength                   decaylength                   decaylength                                                     'F'    [533.83984375,34650.0039062]
(dist_tr)                     _dist_tr_                     (dist_tr)                     (dist_tr)                                                       'F'    [4.01162242889,16639.9101562]
vtx2_bdt2                     vtx2_bdt2                     vtx2_bdt2                     vtx2_bdt2                                                       'F'    [-0.219975918531,0.722600519657]
trk_pms                       trk_pms                       trk_pms                       trk_pms                                                         'F'    [0,59.0778236389]
vtx2_maxap                    vtx2_maxap                    vtx2_maxap                    vtx2_maxap                                                      'F'    [0.000550947035663,1.56121110916]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDTNode

#ifndef BDTNode__def
#define BDTNode__def

class BDTNode {

public:

   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 8 )
   {
      // the training input variables
      const char* inputVars[] = { "tka_rms", "kink", "impact", "decaylength", "(dist_tr)", "vtx2_bdt2", "trk_pms", "vtx2_maxap" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[8];
   double fVmax[8];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[8];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDT::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.924458886591739);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 610.283, 1, 1, 0.907076,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.67817,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331175,-99) , 
5, -0.0607889, 0, 0, 0.584027,-99) , 
6, 4.24226, 0, 0, 0.806248,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.057968,-99) , 
6, 1.05072, 0, 0, 0.305236,-99) , 
NN(
0, 
0, 
-1, 8.86824, 0, -1, 0.05861,-99) , 
3, 16859.7, 0, 0, 0.101618,-99) , 
2, 252.579, 1, 0, 0.510236,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.658787);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.112147, 0, 1, 0.85239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.389734,-99) , 
7, 0.24993, 0, 0, 0.469666,-99) , 
2, 161.216, 1, 0, 0.746898,-99) , 
NN(
0, 
0, 
-1, 0.606037, 0, -1, 0.209095,-99) , 
6, 4.24226, 0, 0, 0.431986,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.712465);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.146792, 1, 1, 0.842102,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.216491,-99) , 
7, 0.0655552, 0, 0, 0.440908,-99) , 
5, 0.139101, 0, 0, 0.66584,-99) , 
NN(
0, 
0, 
-1, 0.370593, 0, -1, 0.0980119,-99) , 
2, 510.381, 1, 0, 0.521955,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.639134);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 216.288, 1, 1, 0.791318,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563954,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.309408,-99) , 
5, 0.0540499, 0, 0, 0.447658,-99) , 
0, 0.0070584, 1, 0, 0.711046,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.69863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.303471,-99) , 
5, 0.155141, 0, 0, 0.461335,-99) , 
NN(
0, 
0, 
-1, 530.528, 1, -1, 0.112171,-99) , 
3, 13130.7, 0, 0, 0.235095,-99) , 
2, 232.48, 1, 0, 0.501305,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.573297);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 77.9427, 1, 1, 0.796074,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.672189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.278614,-99) , 
7, 0.071891, 0, 0, 0.492872,-99) , 
6, 5.28598, 0, 0, 0.664439,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572223,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327389,-99) , 
3, 11464.1, 0, 0, 0.455619,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0340113,-99) , 
4, 3336.63, 0, 0, 0.114316,-99) , 
6, 1.43083, 0, 0, 0.270953,-99) , 
2, 204.55, 1, 0, 0.487357,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.516482);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.877595,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.381154,-99) , 
1, 0.109435, 1, 0, 0.81268,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575812,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346158,-99) , 
7, 0.126041, 0, 0, 0.460077,-99) , 
5, 0.140926, 0, 0, 0.694474,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.19389,-99) , 
7, 0.061899, 0, 0, 0.405043,-99) , 
NN(
0, 
0, 
-1, 754.549, 1, -1, 0.0594936,-99) , 
6, 0.266829, 0, 0, 0.313758,-99) , 
6, 5.62646, 0, 0, 0.449069,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.469144);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.83945,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647378,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379209,-99) , 
6, 8.80996, 0, 0, 0.456386,-99) , 
3, 3618.39, 1, 0, 0.52668,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.206044,-99) , 
0, 0.00831593, 0, 0, 0.354763,-99) , 
NN(
0, 
0, 
-1, 245.037, 1, -1, 0.0587699,-99) , 
7, 0.372991, 0, 0, 0.177728,-99) , 
1, 0.181839, 1, 0, 0.43025,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.516607);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.183371, 0, 1, 0.726216,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584863,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277978,-99) , 
3, 10501.9, 0, 0, 0.429506,-99) , 
3, 5206.16, 1, 0, 0.564806,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339782,-99) , 
5, 0.351304, 0, 0, 0.425206,-99) , 
NN(
0, 
0, 
-1, 0.864191, 0, -1, 0.0803152,-99) , 
6, 2.02371, 0, 0, 0.216443,-99) , 
2, 204.55, 1, 0, 0.425337,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.422608);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.814398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408634,-99) , 
2, 126.601, 1, 0, 0.647695,-99) , 
NN(
0, 
0, 
-1, 315.885, 1, -1, 0.384318,-99) , 
5, 0.22746, 0, 0, 0.472537,-99) , 
NN(
0, 
0, 
-1, 0.370215, 0, -1, 0.126829,-99) , 
2, 510.713, 1, 0, 0.397643,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.394504);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.797184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437208,-99) , 
3, 13734.4, 1, 0, 0.739779,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485705,-99) , 
4, 1593.28, 0, 0, 0.561444,-99) , 
5, 0.209324, 0, 0, 0.635535,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.681995,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.230941,-99) , 
0, 0.00683934, 0, 0, 0.534165,-99) , 
NN(
0, 
0, 
-1, 0.27217, 0, -1, 0.12171,-99) , 
7, 0.37126, 0, 0, 0.285894,-99) , 
1, 0.181839, 1, 0, 0.562548,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.438958);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.318639, 0, 1, 0.727786,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.706774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395406,-99) , 
2, 221.35, 0, 0, 0.456618,-99) , 
2, 92.4635, 1, 0, 0.605242,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565986,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.168634,-99) , 
4, 1846.7, 0, 0, 0.444544,-99) , 
NN(
0, 
0, 
-1, 1148.75, 1, -1, 0.17503,-99) , 
3, 14474.3, 0, 0, 0.273276,-99) , 
2, 273.86, 1, 0, 0.499271,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.41906);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.15047, 0, 1, 0.746919,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.127622,-99) , 
1, 0.075936, 1, 0, 0.503594,-99) , 
7, 0.110163, 0, 0, 0.595568,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.746257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.228466,-99) , 
0, 0.00660882, 0, 0, 0.574594,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502099,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0619202,-99) , 
2, 359.356, 1, 0, 0.209797,-99) , 
7, 0.296908, 0, 0, 0.331599,-99) , 
2, 238.105, 1, 0, 0.494921,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.276985);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.408463, 0, 1, 0.563885,-99) , 
NN(
0, 
0, 
-1, 0.00415299, 0, -1, 0.300733,-99) , 
1, 0.124936, 1, 0, 0.485671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
6, 0.952381, 0, 0, 0.172664,-99) , 
2, 763.826, 1, 0, 0.448132,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.42005);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.77225,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5744,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.265614,-99) , 
0, 0.00468372, 1, 0, 0.496614,-99) , 
7, 0.0604923, 1, 0, 0.596874,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.660016,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.340914,-99) , 
1, 0.182433, 1, 0, 0.518989,-99) , 
NN(
0, 
0, 
-1, 7096.92, 0, -1, 0.26556,-99) , 
7, 0.129721, 0, 0, 0.364203,-99) , 
5, 0.316802, 0, 0, 0.411888,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.286878);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.813168,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644531,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293426,-99) , 
7, 0.475574, 1, 0, 0.537319,-99) , 
3, 14968.5, 0, 0, 0.631755,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0215984,-99) , 
1, 0.125812, 1, 0, 0.474992,-99) , 
NN(
0, 
0, 
-1, 0.095687, 0, -1, 0.0468558,-99) , 
2, 558.312, 1, 0, 0.420012,-99) , 
7, 0.222872, 0, 0, 0.474604,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.328615);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.784194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455817,-99) , 
2, 97.6033, 1, 0, 0.660912,-99) , 
NN(
0, 
0, 
-1, -0.130059, 0, -1, 0.404918,-99) , 
3, 3474.6, 1, 0, 0.457048,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599115,-99) , 
NN(
0, 
0, 
-1, 16288.6, 0, -1, 0.0762601,-99) , 
7, 0.521677, 0, 0, 0.197334,-99) , 
2, 494.15, 1, 0, 0.408746,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.334629);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433587,-99) , 
0, 0.00900632, 1, 0, 0.607502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50911,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.294701,-99) , 
1, 0.0873292, 1, 0, 0.429257,-99) , 
2, 182.462, 1, 0, 0.552269,-99) , 
NN(
0, 
0, 
-1, 17047.1, 0, -1, 0.0762184,-99) , 
2, 544.841, 1, 0, 0.481597,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.220789);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.748544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416024,-99) , 
5, 0.0349145, 1, 0, 0.634862,-99) , 
NN(
0, 
0, 
-1, 0.146128, 1, -1, 0.456579,-99) , 
7, 0.193501, 0, 0, 0.504292,-99) , 
NN(
0, 
0, 
-1, 0.524774, 0, -1, 0.178261,-99) , 
2, 816.462, 1, 0, 0.469601,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.269949);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.735069,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354364,-99) , 
5, 0.0044564, 1, 0, 0.426667,-99) , 
5, 0.453392, 0, 0, 0.4493,-99) , 
NN(
0, 
0, 
-1, 0.296506, 0, -1, 0.165316,-99) , 
2, 764.212, 1, 0, 0.419538,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.294428);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.12113, 1, 1, 0.626445,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.14683,-99) , 
2, 704.275, 1, 0, 0.595767,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461576,-99) , 
4, 785.461, 0, 0, 0.618504,-99) , 
NN(
0, 
0, 
-1, 405.861, 1, -1, 0.356418,-99) , 
7, 0.29782, 0, 0, 0.424573,-99) , 
5, 0.131203, 0, 0, 0.506574,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.327497);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710068,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.650649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475397,-99) , 
2, 122.188, 0, 0, 0.528519,-99) , 
6, 11.2529, 0, 0, 0.56786,-99) , 
NN(
NN(
0, 
0, 
-1, 0.00655089, 0, 1, 0.691347,-99) , 
NN(
0, 
0, 
-1, 0.0933504, 0, -1, 0.22287,-99) , 
7, 0.29782, 0, 0, 0.379987,-99) , 
2, 198.393, 1, 0, 0.490315,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.279237);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582501,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376356,-99) , 
1, 0.160927, 1, 0, 0.546463,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.643572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.155459,-99) , 
7, 0.192112, 0, 0, 0.351419,-99) , 
5, -0.0899553, 0, 0, 0.508117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0673091,-99) , 
2, 1271.02, 1, 0, 0.490749,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.406733);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.737618,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438323,-99) , 
4, 245.742, 1, 0, 0.686162,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368256,-99) , 
0, 0.00400219, 1, 0, 0.430455,-99) , 
3, 4874.7, 1, 0, 0.526646,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.706519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.168774,-99) , 
4, 2541.74, 0, 0, 0.557245,-99) , 
NN(
0, 
0, 
-1, 9.04212, 0, -1, 0.147535,-99) , 
3, 17573.5, 0, 0, 0.305324,-99) , 
2, 248.666, 1, 0, 0.457542,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.277864);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.775916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468147,-99) , 
6, 3.80952, 1, 0, 0.687042,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277205,-99) , 
3, 13560, 1, 0, 0.495371,-99) , 
4, 1286.39, 0, 0, 0.543963,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.722032,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.22859,-99) , 
3, 13397.3, 0, 0, 0.565261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
7, 0.224668, 0, 0, 0.310141,-99) , 
2, 509.974, 1, 0, 0.509462,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.263035);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504772,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.184869,-99) , 
0, 0.0108461, 1, 0, 0.480414,-99) , 
NN(
0, 
0, 
-1, 0.093466, 1, -1, 0.30577,-99) , 
2, 172.38, 1, 0, 0.420878,-99) , 
NN(
0, 
0, 
-1, 0.296506, 0, -1, 0.158588,-99) , 
1, 0.183634, 1, 0, 0.376257,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.347265);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.708864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.325464,-99) , 
3, 7293.62, 1, 0, 0.590997,-99) , 
NN(
0, 
0, 
-1, 2075.16, 0, -1, 0.383298,-99) , 
7, 0.120972, 0, 0, 0.448029,-99) , 
NN(
0, 
0, 
-1, 14762.6, 0, -1, 0.048787,-99) , 
2, 816.565, 1, 0, 0.415946,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.227573);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43739,-99) , 
7, 0.179227, 1, 0, 0.559586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.21381,-99) , 
2, 415.256, 1, 0, 0.547855,-99) , 
NN(
0, 
0, 
-1, 16305.5, 0, -1, 0.222449,-99) , 
2, 544.949, 1, 0, 0.512834,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.338185);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2206.83, 0, 1, 0.734938,-99) , 
NN(
0, 
0, 
-1, 0.168934, 0, -1, 0.385217,-99) , 
3, 2604.32, 1, 0, 0.591913,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587321,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.20152,-99) , 
6, 1.01059, 0, 0, 0.499642,-99) , 
NN(
0, 
0, 
-1, 0.060606, 1, -1, 0.334545,-99) , 
4, 1560.61, 0, 0, 0.383165,-99) , 
3, 3637.17, 1, 0, 0.428531,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.286466);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.652828,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390098,-99) , 
5, -0.132417, 1, 0, 0.40977,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0612971,-99) , 
2, 1089.29, 1, 0, 0.396198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0392297,-99) , 
5, -0.175257, 0, 0, 0.381659,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.245925);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2568.28, 1, 1, 0.587158,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.295497,-99) , 
6, 0.791408, 0, 0, 0.534019,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.211592,-99) , 
3, 1689.38, 1, 0, 0.298014,-99) , 
3, 12670.7, 0, 0, 0.413318,-99) , 
6, 3.33687, 0, 0, 0.51105,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.280141);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655444,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.194477,-99) , 
6, 0.50225, 0, 0, 0.51667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344675,-99) , 
1, 0.241605, 0, 0, 0.375618,-99) , 
6, 3.51976, 1, 0, 0.450041,-99) , 
6, 14.8479, 0, 0, 0.470913,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.203702);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.162723, 0, 1, 0.557577,-99) , 
NN(
0, 
0, 
-1, 0.047711, 0, -1, 0.38594,-99) , 
6, 11.3778, 1, 0, 0.525153,-99) , 
NN(
NN(
0, 
0, 
-1, -0.0371524, 0, 1, 0.605138,-99) , 
NN(
0, 
0, 
-1, 0.137904, 0, -1, 0.0432389,-99) , 
7, 0.521849, 0, 0, 0.322192,-99) , 
1, 0.195407, 1, 0, 0.49459,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.349522);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4507.46, 1, 1, 0.635555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.297202,-99) , 
3, 10293.8, 1, 0, 0.567508,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.174891,-99) , 
6, 3.18043, 1, 0, 0.470235,-99) , 
NN(
0, 
0, 
-1, 0.148327, 0, -1, 0.24126,-99) , 
3, 11323.2, 0, 0, 0.36349,-99) , 
6, 5.62646, 0, 0, 0.45307,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.243386);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685459,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491601,-99) , 
7, 0.238207, 0, 0, 0.530056,-99) , 
NN(
0, 
0, 
-1, 6000.05, 1, -1, 0.150814,-99) , 
2, 492.135, 1, 0, 0.499997,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663447,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.266037,-99) , 
6, 0.763811, 0, 0, 0.491961,-99) , 
NN(
0, 
0, 
-1, 2.25828, 0, -1, 0.248765,-99) , 
6, 1.15504, 1, 0, 0.307514,-99) , 
3, 11516.9, 1, 0, 0.441449,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.314392);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.791155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.179061,-99) , 
4, 265.396, 1, 0, 0.672888,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589252,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396164,-99) , 
3, 9671.79, 0, 0, 0.505871,-99) , 
3, 3783, 1, 0, 0.548882,-99) , 
NN(
NN(
0, 
0, 
-1, 450.92, 1, -1, 0.436239,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540603,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0556832,-99) , 
7, 0.0533664, 0, 0, 0.153851,-99) , 
3, 5223.92, 0, 0, 0.347652,-99) , 
7, 0.0748681, 0, 0, 0.453069,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.296455);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394696,-99) , 
1, 0.024185, 0, 0, 0.507376,-99) , 
NN(
0, 
0, 
-1, 0.0636954, 0, -1, 0.340071,-99) , 
1, 0.0570339, 1, 0, 0.426188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
1, 0.375261, 1, 0, 0.410338,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.391802);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.761025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40366,-99) , 
4, 321.773, 1, 0, 0.652838,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60107,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0818721,-99) , 
0, 0.00601848, 0, 0, 0.415719,-99) , 
3, 10321.6, 1, 0, 0.569424,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60331,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347851,-99) , 
3, 9676.16, 0, 0, 0.438496,-99) , 
NN(
0, 
0, 
-1, 0.00879231, 1, -1, 0.198959,-99) , 
3, 16481.8, 1, 0, 0.390722,-99) , 
5, 0.184184, 0, 0, 0.465315,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.20875);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 7.78671, 0, 1, 0.729183,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.159742,-99) , 
2, 806.827, 1, 0, 0.515234,-99) , 
0, 0.00286159, 1, 0, 0.546069,-99) , 
NN(
0, 
0, 
-1, 259.593, 0, -1, 0.133231,-99) , 
0, 0.0114194, 1, 0, 0.51243,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.124862);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.25982,-99) , 
2, 799.784, 1, 0, 0.498764,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.136741,-99) , 
4, 5453.28, 1, 0, 0.481517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0381137,-99) , 
5, -0.175061, 0, 0, 0.461077,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.317386);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.655283,-99) , 
NN(
0, 
0, 
-1, 325.506, 1, -1, 0.422803,-99) , 
5, 0.363656, 0, 0, 0.471835,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673951,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.210613,-99) , 
0, 0.0143007, 1, 0, 0.473228,-99) , 
NN(
0, 
0, 
-1, -0.0410996, 1, -1, 0.234944,-99) , 
0, 0.0117801, 0, 0, 0.278012,-99) , 
4, 749.221, 1, 0, 0.40102,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.184685);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.674257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49651,-99) , 
0, 0.00342203, 1, 0, 0.540558,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
5, -0.130223, 1, 0, 0.233928,-99) , 
2, 505.931, 1, 0, 0.514899,-99) , 
NN(
0, 
0, 
-1, 0.0401348, 1, -1, 0.322149,-99) , 
3, 15155.1, 1, 0, 0.477389,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.287032);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378728,-99) , 
6, 2.51461, 0, 0, 0.61361,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.843239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449511,-99) , 
3, 2212.14, 1, 0, 0.483375,-99) , 
5, 0.101092, 1, 0, 0.541528,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.243498,-99) , 
2, 296.677, 1, 0, 0.449175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.119262,-99) , 
2, 154.494, 0, 0, 0.342806,-99) , 
5, -0.133448, 0, 0, 0.519704,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.284396);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.540998, 0, 1, 0.785353,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.633558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.336643,-99) , 
6, 2.45689, 0, 0, 0.52979,-99) , 
NN(
0, 
0, 
-1, 0.095019, 0, -1, 0.390709,-99) , 
5, 0.0356696, 1, 0, 0.452781,-99) , 
5, 0.45091, 0, 0, 0.481185,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.358628);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677591,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.239566,-99) , 
5, -0.0879856, 0, 0, 0.638336,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37308,-99) , 
1, 0.0548535, 1, 0, 0.470914,-99) , 
6, 8.1888, 1, 0, 0.563399,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.308488,-99) , 
2, 100.974, 1, 0, 0.480076,-99) , 
NN(
0, 
0, 
-1, 0.00401965, 1, -1, 0.211027,-99) , 
2, 256.69, 1, 0, 0.347535,-99) , 
6, 2.12113, 0, 0, 0.507334,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.36445);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.374394,-99) , 
7, 0.0303437, 0, 0, 0.622072,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.360861,-99) , 
6, 1.02591, 1, 0, 0.447377,-99) , 
0, 0.00708213, 1, 0, 0.563812,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.626626,-99) , 
NN(
0, 
0, 
-1, 4905.98, 0, -1, 0.196706,-99) , 
0, 0.0112273, 0, 0, 0.29313,-99) , 
1, 0.182637, 1, 0, 0.51961,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.231701);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 93.6434, 1, 1, 0.655752,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422656,-99) , 
3, 9636.5, 0, 0, 0.493366,-99) , 
5, 0.2721, 0, 0, 0.535955,-99) , 
NN(
0, 
0, 
-1, 0.0106117, 1, -1, 0.249608,-99) , 
4, 2239.31, 1, 0, 0.507226,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.457854);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.214974, 0, 1, 0.702059,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.767067,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315408,-99) , 
4, 214.973, 1, 0, 0.508313,-99) , 
0, 0.00583531, 0, 0, 0.623099,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.765236,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.744522,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.29468,-99) , 
7, 0.0672375, 0, 0, 0.364155,-99) , 
3, 20565.8, 0, 0, 0.426178,-99) , 
7, 0.0743129, 0, 0, 0.530945,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.235736);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.72039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.218768,-99) , 
2, 336.233, 1, 0, 0.666676,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.808958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48743,-99) , 
2, 382.468, 0, 0, 0.516282,-99) , 
6, 2.12113, 1, 0, 0.560675,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573381,-99) , 
NN(
0, 
0, 
-1, 0.171831, 0, -1, 0.0686742,-99) , 
7, 0.372991, 0, 0, 0.262114,-99) , 
2, 503.561, 1, 0, 0.529032,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.228808);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423185,-99) , 
3, 5157.81, 0, 0, 0.512015,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503447,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.189017,-99) , 
3, 8183.79, 1, 0, 0.369497,-99) , 
5, -0.0481242, 0, 0, 0.480164,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.724003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.266657,-99) , 
5, -0.00832754, 1, 0, 0.472704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
6, 0.952381, 0, 0, 0.279667,-99) , 
2, 509.365, 1, 0, 0.458605,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.306249);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625066,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.367811,-99) , 
3, 15889.7, 1, 0, 0.597524,-99) , 
NN(
0, 
0, 
-1, 12243.5, 0, -1, 0.350042,-99) , 
4, 1494.12, 1, 0, 0.552666,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692649,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407621,-99) , 
2, 195.463, 1, 0, 0.563841,-99) , 
NN(
0, 
0, 
-1, 4808.48, 1, -1, 0.262838,-99) , 
0, 0.00918524, 0, 0, 0.373908,-99) , 
5, -0.0409329, 0, 0, 0.508329,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.24451);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378078,-99) , 
5, -0.0408179, 0, 0, 0.553104,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369908,-99) , 
6, 1.02591, 1, 0, 0.41771,-99) , 
0, 0.00658741, 1, 0, 0.507508,-99) , 
NN(
0, 
0, 
-1, 1.90476, 0, -1, 0.208524,-99) , 
2, 503.561, 1, 0, 0.480873,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.136498);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.779871,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478132,-99) , 
0, 0.00578111, 1, 0, 0.626554,-99) , 
NN(
0, 
0, 
-1, 0.189182, 1, -1, 0.471229,-99) , 
5, -0.0466498, 1, 0, 0.508092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.163169,-99) , 
5, -0.174895, 0, 0, 0.495043,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.253945);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39505,-99) , 
6, 6.15544, 1, 0, 0.59816,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537511,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.358101,-99) , 
6, 5.62646, 0, 0, 0.448621,-99) , 
5, 0.0045711, 1, 0, 0.495866,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641161,-99) , 
NN(
0, 
0, 
-1, 0.366009, 0, -1, 0.225867,-99) , 
5, -0.130223, 1, 0, 0.317193,-99) , 
1, 0.189061, 1, 0, 0.470884,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.258756);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.710067,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.674065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430284,-99) , 
6, 6.07015, 1, 0, 0.51345,-99) , 
6, 11.9409, 0, 0, 0.569381,-99) , 
NN(
0, 
0, 
-1, 0.363619, 1, -1, 0.384432,-99) , 
6, 4.24226, 0, 0, 0.488499,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.242727);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 642.242, 0, 1, 0.675966,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507426,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.292725,-99) , 
7, 0.0685233, 0, 0, 0.453964,-99) , 
1, 0.0298718, 1, 0, 0.538436,-99) , 
NN(
0, 
0, 
-1, 0.370215, 0, -1, 0.225207,-99) , 
1, 0.194531, 1, 0, 0.508185,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.341362);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.176124, 0, 1, 0.762474,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.774466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477781,-99) , 
5, 0.446476, 0, 0, 0.553462,-99) , 
5, 0.195333, 1, 0, 0.60674,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586139,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.303891,-99) , 
1, 0.158681, 1, 0, 0.517245,-99) , 
NN(
0, 
0, 
-1, 302.426, 1, -1, 0.248333,-99) , 
0, 0.00859412, 0, 0, 0.341754,-99) , 
5, 0.139316, 0, 0, 0.48564,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.234256);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 305.172, 1, 1, 0.701928,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.708526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437098,-99) , 
3, 23329.8, 0, 0, 0.458362,-99) , 
0, 0.00349087, 1, 0, 0.512433,-99) , 
NN(
0, 
0, 
-1, 0.0633837, 1, -1, 0.309123,-99) , 
5, 0.406091, 1, 0, 0.483884,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.393152);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 7645.56, 1, 1, 0.753944,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.245456,-99) , 
5, 0.186562, 0, 0, 0.45188,-99) , 
5, -0.00756357, 1, 0, 0.628843,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646733,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.261059,-99) , 
1, 0.0439049, 1, 0, 0.547224,-99) , 
NN(
0, 
0, 
-1, 0.0565538, 0, -1, 0.346515,-99) , 
2, 187.134, 1, 0, 0.489092,-99) , 
7, 0.149185, 0, 0, 0.534684,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.202269);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.709095,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.73614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471447,-99) , 
2, 215.452, 0, 0, 0.527057,-99) , 
NN(
0, 
0, 
-1, 1.47804, 0, -1, 0.280671,-99) , 
2, 346.682, 1, 0, 0.493284,-99) , 
3, 25338.5, 0, 0, 0.507035,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.208175);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.659005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489051,-99) , 
4, 1280.16, 0, 0, 0.531313,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.227231,-99) , 
2, 764.609, 1, 0, 0.509834,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56607,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.316326,-99) , 
1, 0.0613156, 1, 0, 0.437397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
1, 0.149571, 1, 0, 0.367911,-99) , 
6, 8.48452, 1, 0, 0.464639,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.232097);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0161486, 1, 1, 0.599022,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.253991,-99) , 
1, 0.289768, 1, 0, 0.586798,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0617597,-99) , 
7, 0.516884, 0, 0, 0.325121,-99) , 
2, 712.084, 1, 0, 0.572918,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.25037);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.763538,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492893,-99) , 
7, 0.0710974, 1, 0, 0.57721,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.365384,-99) , 
4, 2349, 0, 0, 0.423225,-99) , 
7, 0.0490968, 0, 0, 0.527332,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343845,-99) , 
0, 0.0072644, 0, 0, 0.520474,-99) , 
NN(
0, 
0, 
-1, 1998.27, 1, -1, 0.145899,-99) , 
3, 6428.99, 0, 0, 0.342006,-99) , 
1, 0.179171, 1, 0, 0.503347,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.27917);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 9191.48, 0, 1, 0.613602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0763692,-99) , 
3, 3664.99, 1, 0, 0.35589,-99) , 
1, 0.189182, 1, 0, 0.58373,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.243037,-99) , 
5, -0.0998687, 0, 0, 0.542374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.133765,-99) , 
0, 0.00431109, 0, 0, 0.449675,-99) , 
3, 13530.5, 1, 0, 0.547678,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.258257);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484002,-99) , 
1, 0.204568, 1, 0, 0.598292,-99) , 
NN(
0, 
0, 
-1, 0.135364, 1, -1, 0.315973,-99) , 
5, 0.350822, 1, 0, 0.558606,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517982,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.314215,-99) , 
3, 8162.36, 0, 0, 0.421816,-99) , 
NN(
0, 
0, 
-1, 0.0994, 0, -1, 0.118719,-99) , 
7, 0.0603983, 1, 0, 0.378704,-99) , 
7, 0.0745786, 0, 0, 0.479355,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.191452);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.819029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.262155,-99) , 
0, 0.00851376, 1, 0, 0.689054,-99) , 
NN(
0, 
0, 
-1, 603.827, 1, -1, 0.435313,-99) , 
3, 20590.9, 0, 0, 0.467528,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.222759);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.0237681, 1, 1, 0.708609,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.113186,-99) , 
7, 0.0182838, 0, 0, 0.507139,-99) , 
NN(
0, 
0, 
-1, 11428.9, 1, -1, 0.235511,-99) , 
2, 238.105, 1, 0, 0.456712,-99) , 
7, 0.369361, 0, 0, 0.491734,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.314951);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0403173, 1, 1, 0.795146,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640296,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27513,-99) , 
0, 0.00665327, 1, 0, 0.447241,-99) , 
6, 2.61805, 0, 0, 0.690621,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.648078,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354697,-99) , 
5, -0.175037, 0, 0, 0.584469,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538611,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.321791,-99) , 
3, 5552.39, 1, 0, 0.405262,-99) , 
5, -0.0850239, 1, 0, 0.440575,-99) , 
1, 0.189061, 0, 0, 0.484674,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.225281);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.757799,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335588,-99) , 
0, 0.00330199, 0, 0, 0.477299,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573136,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283369,-99) , 
4, 3976.77, 0, 0, 0.326257,-99) , 
0, 0.00714898, 1, 0, 0.43168,-99) , 
7, 0.743869, 0, 0, 0.449278,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.273782);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.723955,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375021,-99) , 
4, 799.589, 0, 0, 0.511283,-99) , 
6, 10.0158, 0, 0, 0.555601,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596545,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.269138,-99) , 
0, 0.00309938, 0, 0, 0.548668,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.274827,-99) , 
7, 0.0536736, 1, 0, 0.411101,-99) , 
7, 0.140144, 0, 0, 0.466545,-99) , 
3, 8278.02, 0, 0, 0.50843,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.228841);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60745,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434729,-99) , 
3, 2956.89, 1, 0, 0.479533,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0695149,-99) , 
1, 0.355855, 1, 0, 0.465842,-99) , 
NN(
0, 
0, 
-1, 2365.33, 0, -1, 0.184117,-99) , 
3, 17498.9, 1, 0, 0.435644,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.300097);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.650189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416946,-99) , 
3, 11329.8, 1, 0, 0.58751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329168,-99) , 
5, 0.389383, 1, 0, 0.55027,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688402,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456612,-99) , 
5, 0.165227, 0, 0, 0.572579,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.180733,-99) , 
0, 0.00440262, 1, 0, 0.331623,-99) , 
7, 0.0464438, 0, 0, 0.427086,-99) , 
7, 0.0748681, 0, 0, 0.489267,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.225193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.245324, 0, 1, 0.591481,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.237559,-99) , 
4, 611.803, 1, 0, 0.465324,-99) , 
6, 2.81323, 1, 0, 0.519648,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.132458,-99) , 
0, 0.00302521, 1, 0, 0.262958,-99) , 
5, 0.427876, 1, 0, 0.494478,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.331425);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.678488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487949,-99) , 
4, 3691.03, 1, 0, 0.62101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.307239,-99) , 
2, 1093.03, 1, 0, 0.584261,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385903,-99) , 
0, 0.00293165, 1, 0, 0.458396,-99) , 
NN(
0, 
0, 
-1, 1.91731, 1, -1, 0.254375,-99) , 
6, 4.04743, 0, 0, 0.384083,-99) , 
4, 1560.76, 0, 0, 0.435603,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.33968);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.30831, 0, 1, 0.671652,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293138,-99) , 
7, 0.0659708, 0, 0, 0.477065,-99) , 
6, 6.07114, 1, 0, 0.576764,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.711027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.261474,-99) , 
2, 236.592, 1, 0, 0.596335,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.258545,-99) , 
7, 0.148327, 0, 0, 0.387423,-99) , 
5, -0.119002, 1, 0, 0.470545,-99) , 
5, 0.0826667, 0, 0, 0.529814,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.204448);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.612334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413871,-99) , 
5, 0.0851701, 0, 0, 0.529359,-99) , 
NN(
0, 
0, 
-1, 8056.64, 1, -1, 0.416632,-99) , 
3, 9822.07, 0, 0, 0.459246,-99) , 
NN(
0, 
0, 
-1, 0.00899235, 0, -1, 0.267949,-99) , 
2, 544.841, 1, 0, 0.44489,-99)    );
   return;
};

// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
